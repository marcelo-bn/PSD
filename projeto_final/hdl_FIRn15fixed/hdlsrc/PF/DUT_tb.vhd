-- -------------------------------------------------------------
--
-- Module: DUT_tb
-- Path: /home/aluno/Documentos/PSD/PF/hdl_FIRn15fixed/hdlsrc/PF
-- Created: 2020-08-11 08:07:09
-- Generated by MATLAB 8.5 and HDL Coder 3.6
-- Hierarchy Level: 1
--
--
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.all;
USE IEEE.numeric_std.ALL;
USE STD.textio.ALL;
USE IEEE.std_logic_textio.ALL;

USE work.DUT_tb_pkg.ALL;

USE work.DUT_tb_data.ALL;

ENTITY DUT_tb IS

END DUT_tb;


ARCHITECTURE rtl OF DUT_tb IS
  -- -------------------------------------------------------------
  -- Component Declarations
  -- -------------------------------------------------------------
  COMPONENT DUT
   PORT( clk                             :   IN    std_logic; 
         reset                           :   IN    std_logic; 
         clk_enable                      :   IN    std_logic; 
         X                               :   IN    std_logic_vector(15 DOWNTO 0); -- sfix16_En15
         ce_out                          :   OUT   std_logic; 
         Y                               :   OUT   std_logic_vector(27 DOWNTO 0)  -- sfix28_En23
         );
  END COMPONENT;

  -- -------------------------------------------------------------
  -- Component Configuration Statements
  -- -------------------------------------------------------------
  FOR ALL : DUT
    USE ENTITY work.DUT(rtl);

  -- Constants
  CONSTANT clk_high                         : time := 5 ns;
  CONSTANT clk_low                          : time := 5 ns;
  CONSTANT clk_period                       : time := 10 ns;
  CONSTANT clk_hold                         : time := 2 ns;
  CONSTANT MAX_ERROR_COUNT                : integer := 16001; -- uint32


  -- Signals
  SIGNAL clk                              : std_logic; -- boolean
  SIGNAL reset                            : std_logic; -- boolean
  SIGNAL clk_enable                       : std_logic; -- boolean
  SIGNAL X                                : std_logic_vector(15 DOWNTO 0); -- sfix16_En15
  SIGNAL ce_out                           : std_logic; -- boolean
  SIGNAL Y                                : std_logic_vector(27 DOWNTO 0); -- sfix28_En23

  SIGNAL tb_enb                           : std_logic; -- boolean
  SIGNAL srcDone                          : std_logic; -- boolean
  SIGNAL snkDone                          : std_logic; -- boolean
  SIGNAL testFailure                      : std_logic; -- boolean
  SIGNAL tbenb_dly                        : std_logic; -- boolean
  SIGNAL rdEnb                            : std_logic; -- boolean
  SIGNAL Data_Type_Conversion_out1_rdenb  : std_logic; -- boolean
  SIGNAL Data_Type_Conversion_out1_addr   : unsigned(13 DOWNTO 0); -- ufix14
  SIGNAL Data_Type_Conversion_out1_done   : std_logic; -- boolean
  SIGNAL Y_testFailure                    : std_logic; -- boolean
  SIGNAL Y_errCnt                         : integer; -- uint32
  SIGNAL Y_rdenb                          : std_logic; -- boolean
  SIGNAL Y_addr                           : unsigned(13 DOWNTO 0); -- ufix14
  SIGNAL Y_done                           : std_logic; -- boolean
  SIGNAL Y_ref                            : std_logic_vector(27 DOWNTO 0); -- sfix28_En23
  SIGNAL check1_Done                      : std_logic; -- boolean


BEGIN
  -- Component Instances
  u_DUT: DUT
    PORT MAP (
              clk                              => clk,
              reset                            => reset,
              clk_enable                       => clk_enable,
              X                                => X,
              ce_out                           => ce_out,
              Y                                => Y      );


  -- Block Statements
  -- -------------------------------------------------------------
  -- Driving the test bench enable
  -- -------------------------------------------------------------

  tb_enb <= '0' WHEN reset = '1' ELSE 
            '1' WHEN snkDone = '0' ELSE 
            '0' AFTER clk_period * 2;

  completed_msg: PROCESS (clk, reset)
  BEGIN
    IF (reset = '1') THEN 
       -- Nothing to reset here.
    ELSIF clk'event AND clk = '1' THEN
      IF snkDone='1' THEN
        IF (testFailure = '0') THEN
              ASSERT FALSE
                REPORT "**************TEST COMPLETED (PASSED)**************"
                SEVERITY NOTE;
        ELSE
              ASSERT FALSE
                REPORT "**************TEST COMPLETED (FAILED)**************"
                SEVERITY NOTE;
        END IF;
      END IF;
    END IF;
  END PROCESS completed_msg;

  -- -------------------------------------------------------------
  -- System Clock (fast clock) and reset
  -- -------------------------------------------------------------

  clk_gen: PROCESS
  BEGIN
    clk <= '1';
    WAIT FOR clk_high;
    clk <= '0';
    WAIT FOR clk_low;
    IF snkDone = '1' THEN
      clk <= '1';
      WAIT FOR clk_high;
      clk <= '0';
      WAIT FOR clk_low;
      WAIT;
    END IF;
  END PROCESS clk_gen;

  reset_gen: PROCESS
  BEGIN
    reset <= '1';
    WAIT FOR clk_period * 2;
    WAIT UNTIL clk'event AND clk = '1';
    WAIT FOR clk_hold;
    reset <= '0';
    WAIT;
  END PROCESS reset_gen;

  -- -------------------------------------------------------------
  -- Testbench clock enable
  -- -------------------------------------------------------------

  tb_enb_delay : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      tbenb_dly <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF tb_enb = '1' THEN
        tbenb_dly <= tb_enb;
      END IF;
    END IF; 
  END PROCESS tb_enb_delay;

  rdEnb <= tbenb_dly WHEN snkDone =  '0' ELSE
           '0';

  -- -------------------------------------------------------------
  -- Read the data and transmit it to the DUT
  -- -------------------------------------------------------------

  Data_Type_Conversion_out1_procedure (
    clk       => clk,
    reset     => reset,
    rdenb     => Data_Type_Conversion_out1_rdenb,
    addr      => Data_Type_Conversion_out1_addr,
    done      => Data_Type_Conversion_out1_done);

  Data_Type_Conversion_out1_rdenb <= rdEnb;

              stimuli_Data_Type_Conversion_out1 : PROCESS(Data_Type_Conversion_out1_addr, Data_Type_Conversion_out1_rdenb)
  FILE fp_X :TEXT OPEN READ_MODE IS "X.dat";
  VARIABLE line_X :line;
  VARIABLE X_expected :std_logic_vector(15 DOWNTO 0);
  VARIABLE data_X_1 :std_logic_vector(15 DOWNTO 0);
  BEGIN
    IF Data_Type_Conversion_out1_rdenb = '1' THEN
      IF  not (ENDFILE(fp_X)) THEN
            readline(fp_X,line_X);
            hread(line_X,data_X_1);
       END IF;
      X <= (SLICE(to_bitvector(data_X_1),16))AFTER clk_hold;
    END IF;
  END PROCESS stimuli_Data_Type_Conversion_out1;

  -- -------------------------------------------------------------
  -- Create done signal for Input data
  -- -------------------------------------------------------------

  srcDone <= Data_Type_Conversion_out1_done;

  -- -------------------------------------------------------------
  --  Checker: Checking the data received from the DUT.
  -- -------------------------------------------------------------

  Y_procedure (
    clk       => clk,
    reset     => reset,
    rdenb     => Y_rdenb,
    addr      => Y_addr,
    done      => Y_done);

  Y_rdenb <= ce_out;

  checker_1: PROCESS(clk, reset)
  FILE fp_Y :TEXT OPEN READ_MODE IS "Y.dat";
  VARIABLE line_Y :line;
  VARIABLE Y_expected :std_logic_vector(27 DOWNTO 0);
  VARIABLE data_Y_1 :std_logic_vector(27 DOWNTO 0);
  BEGIN
    IF reset = '1' THEN
      Y_errCnt <= 0;
      Y_testFailure <= '0';
    ELSIF clk'event and clk ='1' THEN
      IF Y_rdenb = '1' THEN
      IF  not (ENDFILE(fp_Y)) THEN
            readline(fp_Y,line_Y);
            hread(line_Y,data_Y_1);
       END IF;
      Y_expected := (SLICE(to_bitvector(data_Y_1),28));
      Y_ref <= Y_expected;
        IF Y /= Y_expected THEN
          Y_errCnt <= Y_errCnt + 1;
          Y_testFailure <= '1';
          ASSERT FALSE 
            REPORT "Error in Y: Expected " 
            & to_hex(Y_expected)
            & " Actual "
            & to_hex(Y)
            SEVERITY ERROR;
          IF Y_errCnt >= MAX_ERROR_COUNT THEN
            ASSERT FALSE
              REPORT "Number of errors have exceeded the maximum error"
              SEVERITY Warning;
          END IF;
        END IF;
      END IF;
    END IF;
  END PROCESS checker_1;

  checkDone_1: PROCESS(clk, reset)
  BEGIN
    IF reset = '1' THEN
      check1_Done <= '0';
    ELSIF clk'event and clk ='1' THEN
      IF check1_Done = '0' AND Y_done = '1' AND Y_rdenb = '1' THEN
        check1_Done <= '1';
      END IF;
    END IF;
  END PROCESS checkDone_1;
  -- -------------------------------------------------------------
  -- Create done and test failure signal for output data
  -- -------------------------------------------------------------

  snkDone <= check1_Done;

  testFailure <= Y_testFailure;

  -- -------------------------------------------------------------
  -- Global clock enable
  -- -------------------------------------------------------------
  clk_enable <= tbenb_dly AFTER clk_hold WHEN snkDone = '0' ELSE
                '0' AFTER clk_hold;

  -- Assignment Statements



END rtl;
